<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 3D 다각형 애니메이션</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            color: white;
            border-radius: 5px;
        }
        .controls button, .controls select {
            margin: 5px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="controls">
        <div>
            <label for="shapeSelect">도형: </label>
            <select id="shapeSelect">
                <option value="cube">정육면체</option>
                <option value="pyramid">사각뿔</option>
                <option value="octahedron">팔면체</option>
            </select>
        </div>
        <div>
            <label for="rotationSpeed">회전 속도: </label>
            <input type="range" id="rotationSpeed" min="0.1" max="5" step="0.1" value="1">
        </div>
        <div>
            <button id="colorToggle">색상 변경</button>
        </div>
    </div>

    <script>
        // WebGL 초기화 및 메인 코드
        let gl;
        let shaderProgram;
        let rotationSpeed = 1.0;
        let colorToggleState = 0;
        let currentShape = 'cube';
        
        // 초기화 함수
        function init() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');
            
            if (!gl) {
                alert('WebGL을 지원하지 않는 브라우저입니다.');
                return;
            }
            
            // 캔버스 크기 설정
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 셰이더 초기화
            initShaders();
            
            // 컨트롤 이벤트 리스너 설정
            document.getElementById('shapeSelect').addEventListener('change', function(e) {
                currentShape = e.target.value;
            });
            
            document.getElementById('rotationSpeed').addEventListener('input', function(e) {
                rotationSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('colorToggle').addEventListener('click', function() {
                colorToggleState = (colorToggleState + 1) % 3;
            });
            
            // 애니메이션 시작
            animate();
        }
        
        function resizeCanvas() {
            const canvas = document.getElementById('glCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        // 셰이더 초기화
        function initShaders() {
            // 버텍스 셰이더
            const vertexShaderSource = `
                attribute vec3 aVertexPosition;
                attribute vec3 aVertexColor;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                varying vec3 vColor;
                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
                    vColor = aVertexColor;
                }
            `;
            
            // 프래그먼트 셰이더
            const fragmentShaderSource = `
                precision mediump float;
                varying vec3 vColor;
                void main(void) {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `;
            
            // 셰이더 컴파일
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            // 셰이더 프로그램 생성 및 링크
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('셰이더를 초기화할 수 없습니다.');
                return;
            }
            
            gl.useProgram(shaderProgram);
            
            // 셰이더 변수 위치 가져오기
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
            
            shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, 'aVertexColor');
            gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
            
            shaderProgram.projectionMatrixUniform = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
            shaderProgram.modelViewMatrixUniform = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
        }
        
        // 애니메이션 루프
        let rotation = 0;
        function animate() {
            requestAnimationFrame(animate);
            drawScene();
            rotation += 0.01 * rotationSpeed;
        }
        
        // 장면 그리기
        function drawScene() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // 원근 투영 행렬 설정
            const projectionMatrix = makePerspective(45, gl.canvas.width / gl.canvas.height, 0.1, 100.0);
            
            // 모델뷰 행렬 설정
            const modelViewMatrix = makeIdentity();
            matrixTranslate(modelViewMatrix, [0, 0, -5.0]);
            matrixRotate(modelViewMatrix, rotation, [1, 1, 0]);
            
            // 행렬 적용
            gl.uniformMatrix4fv(shaderProgram.projectionMatrixUniform, false, new Float32Array(projectionMatrix));
            gl.uniformMatrix4fv(shaderProgram.modelViewMatrixUniform, false, new Float32Array(modelViewMatrix));
            
            // 도형 그리기
            switch(currentShape) {
                case 'cube':
                    drawCube();
                    break;
                case 'pyramid':
                    drawPyramid();
                    break;
                case 'octahedron':
                    drawOctahedron();
                    break;
            }
        }
        
        // 정육면체 그리기
        function drawCube() {
            // 정점 데이터
            const vertices = [
                // 앞면
                -1.0, -1.0,  1.0,
                 1.0, -1.0,  1.0,
                 1.0,  1.0,  1.0,
                -1.0,  1.0,  1.0,
                
                // 뒷면
                -1.0, -1.0, -1.0,
                -1.0,  1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0, -1.0, -1.0,
                
                // 윗면
                -1.0,  1.0, -1.0,
                -1.0,  1.0,  1.0,
                 1.0,  1.0,  1.0,
                 1.0,  1.0, -1.0,
                
                // 아랫면
                -1.0, -1.0, -1.0,
                 1.0, -1.0, -1.0,
                 1.0, -1.0,  1.0,
                -1.0, -1.0,  1.0,
                
                // 오른쪽면
                 1.0, -1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0,  1.0,  1.0,
                 1.0, -1.0,  1.0,
                
                // 왼쪽면
                -1.0, -1.0, -1.0,
                -1.0, -1.0,  1.0,
                -1.0,  1.0,  1.0,
                -1.0,  1.0, -1.0
            ];
            
            // 색상 데이터
            let colors = [];
            for (let i = 0; i < 6; i++) {
                const faceColors = getColor(i);
                colors = colors.concat(faceColors, faceColors, faceColors, faceColors);
            }
            
            // 인덱스 데이터
            const indices = [
                0,  1,  2,      0,  2,  3,    // 앞면
                4,  5,  6,      4,  6,  7,    // 뒷면
                8,  9,  10,     8,  10, 11,   // 윗면
                12, 13, 14,     12, 14, 15,   // 아랫면
                16, 17, 18,     16, 18, 19,   // 오른쪽면
                20, 21, 22,     20, 22, 23    // 왼쪽면
            ];
            
            // 정점 버퍼 생성
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 색상 버퍼 생성
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 인덱스 버퍼 생성
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // 그리기
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }
        
        // 사각뿔 그리기
        function drawPyramid() {
            // 정점 데이터
            const vertices = [
                // 바닥
                -1.0, -1.0, -1.0,
                 1.0, -1.0, -1.0,
                 1.0, -1.0,  1.0,
                -1.0, -1.0,  1.0,
                
                // 꼭지점
                 0.0,  1.0,  0.0
            ];
            
            // 색상 데이터
            let colors = [];
            for (let i = 0; i < 4; i++) {
                const faceColor = getColor(i);
                colors = colors.concat(faceColor);
            }
            colors = colors.concat(getColor(4)); // 꼭지점 색상
            
            // 인덱스 데이터
            const indices = [
                0, 1, 2,      0, 2, 3,    // 바닥
                0, 4, 1,                  // 측면 1
                1, 4, 2,                  // 측면 2
                2, 4, 3,                  // 측면 3
                3, 4, 0                   // 측면 4
            ];
            
            // 정점 버퍼 생성
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 색상 버퍼 생성
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 인덱스 버퍼 생성
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // 그리기
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }
        
        // 팔면체 그리기
        function drawOctahedron() {
            // 정점 데이터
            const vertices = [
                 0.0,  1.0,  0.0,  // 상단 꼭지점
                 1.0,  0.0,  0.0,  // 우측
                 0.0,  0.0,  1.0,  // 앞
                -1.0,  0.0,  0.0,  // 좌측
                 0.0,  0.0, -1.0,  // 뒤
                 0.0, -1.0,  0.0   // 하단 꼭지점
            ];
            
            // 색상 데이터
            let colors = [];
            for (let i = 0; i < 6; i++) {
                colors = colors.concat(getColor(i));
            }
            
            // 인덱스 데이터
            const indices = [
                0, 1, 2,    // 상단 1
                0, 2, 3,    // 상단 2
                0, 3, 4,    // 상단 3
                0, 4, 1,    // 상단 4
                5, 2, 1,    // 하단 1
                5, 3, 2,    // 하단 2
                5, 4, 3,    // 하단 3
                5, 1, 4     // 하단 4
            ];
            
            // 정점 버퍼 생성
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 색상 버퍼 생성
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 3, gl.FLOAT, false, 0, 0);
            
            // 인덱스 버퍼 생성
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // 그리기
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }
        
        // 색상 가져오기
        function getColor(index) {
            switch (colorToggleState) {
                case 0: // 기본 다색 모드
                    const colors = [
                        [1.0, 0.0, 0.0],  // 빨강
                        [0.0, 1.0, 0.0],  // 초록
                        [0.0, 0.0, 1.0],  // 파랑
                        [1.0, 1.0, 0.0],  // 노랑
                        [1.0, 0.0, 1.0],  // 마젠타
                        [0.0, 1.0, 1.0]   // 시안
                    ];
                    return colors[index % colors.length];
                    
                case 1: // 무지개 그라데이션 모드
                    const time = Date.now() * 0.001;
                    const r = Math.sin(time + index * 0.5) * 0.5 + 0.5;
                    const g = Math.sin(time + index * 0.5 + 2) * 0.5 + 0.5;
                    const b = Math.sin(time + index * 0.5 + 4) * 0.5 + 0.5;
                    return [r, g, b];
                    
                case 2: // 단색 모드
                    return [0.5, 0.5, 0.8];
            }
        }
        
        // 행렬 유틸리티 함수들
        function makeIdentity() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }
        
        function matrixTranslate(matrix, translation) {
            const x = translation[0];
            const y = translation[1];
            const z = translation[2];
            
            matrix[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
            matrix[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
            matrix[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
            matrix[15] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
        }
        
        function matrixRotate(matrix, angle, axis) {
            let x = axis[0];
            let y = axis[1];
            let z = axis[2];
            
            const len = Math.sqrt(x * x + y * y + z * z);
            if (len === 0) {
                return;
            }
            
            x /= len;
            y /= len;
            z /= len;
            
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const t = 1 - c;
            
            const a00 = matrix[0], a01 = matrix[1], a02 = matrix[2], a03 = matrix[3];
            const a10 = matrix[4], a11 = matrix[5], a12 = matrix[6], a13 = matrix[7];
            const a20 = matrix[8], a21 = matrix[9], a22 = matrix[10], a23 = matrix[11];
            
            // 회전 행렬 계산
            const b00 = x * x * t + c;
            const b01 = y * x * t + z * s;
            const b02 = z * x * t - y * s;
            
            const b10 = x * y * t - z * s;
            const b11 = y * y * t + c;
            const b12 = z * y * t + x * s;
            
            const b20 = x * z * t + y * s;
            const b21 = y * z * t - x * s;
            const b22 = z * z * t + c;
            
            // 행렬 곱셈
            matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
            matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
            matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
            matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
            
            matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
            matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
            matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
            matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
            
            matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
            matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
            matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
            matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
        }
        
        function makePerspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy * Math.PI / 360);
            const rangeInv = 1 / (near - far);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ];
        }
        
        // 페이지 로드 시 초기화
        window.onload = init;
    </script>
</body>
</html>
